####The following code are used to generate binary network with a give degree sequence
####methodology reference:
##  @article{Bayati2010sequence,
##  author={Mohsen Bayati and Jeong Han Kim and Amin Saberi},
##  title={A Sequential Algorithm for Generating Random Graphs},
##  journal={Algorithmica},
##  year={2010},
##  volume={58},
##  number={4},
##  pages={860-910},
##  }

####CutMatrix() function cut the target matrix into several blocks
####according to tree structure
####input: TreeA=Row tree, TreeB=Column tree, 
####		N1=# of cluster in row tree
####		N2=# of cluster in column tree
####output: a list of sub-block or original matrix
CutMatrix = function(TreeA, TreeB, N1, N2, Matrix){
	
	CutR = cutree(TreeA, k=N1)
	CutC = cutree(TreeB, k=N2)
	GroupR = unique(CutR[TreeA$order])
	GroupC = unique(CutC[TreeB$order])
	BlockMat=lapply(1:N2, function(xx){
		MemberC=which(CutC==GroupC[xx])
		MatCol=lapply(1:N1, function(yy){
			MemberR=which(CutR==GroupR[yy])
			matrix(Matrix[MemberR,MemberC], 	
				nrow=length(MemberR),ncol=length(MemberC))
		}) ##end of MatCol	
	})  ##end of BlockMat
	return(BlockMat)
}

####ConvertAdj() function convert a transition matrix into adjacency matrix A
####input:  Mat = bipartite matrix
####output: A = adjacency matrix A(row first column second)

ConvertAdj = function(Mat){
	
	Nall = nrow(Mat)+ncol(Mat)
	AdjM = matrix(0, nrow=Nall, ncol=Nall)
	for (i in 1:nrow(Mat)){
		AdjM[i, ] = c(rep(0,nrow(Mat)), Mat[i,])
	}
	AdjMF=t(AdjM)+AdjM
	return(AdjMF)
}

####ConvertEtoA() function convert an edge matrix into adjacency matrix 
####input:  EdgeM = Edge Matrix generated by bayati
####        Ns = # of node 
####output: MatA = adjacency matrix

ConvertEtoA = function(EdgeM, Ns){
	
	NewA = matrix(0, nrow=Ns, ncol=Ns)
	for (j in 1:ncol(EdgeM)){
		v1=EdgeM[1,j]
		v2=EdgeM[2,j]
		NewA[v1, v2]=1
		NewA[v2, v1]=1
	}
	return(NewA)
}

####RamPerm() function randomly permute row and column for a bipartite matrix
####input:  BiMat=target bipartite matrix
####output: new matrix after permutation

RamPerm = function(BiMat){
	
	NR=nrow(BiMat)
	NC=ncol(BiMat)
	Sr=sample(seq(NR), NR, replace=FALSE)
	Sc=sample(seq(NC), NC, replace=FALSE)
	NewMat=BiMat[Sr, Sc]
	return(NewMat)
}

####GenbyBayati() function generate a new data matrix
####              by block structure and Bayati algorithm
####input: TreeA=Row tree, TreeB=Column tree, 
####		N1=# of cluster in row tree
####		N2=# of cluster in column tree
####output: new matrix with fix block structure


GenbyBayati = function(TreeA, TreeB, N1, N2, Matrix){
	
	##chop the original matrix by each block
	OldBlocl=CutMatrix(TreeA, TreeB, N1, N2, Matrix)
	NewBlocl=OldBlocl
	
	##for each block, generate a new bootstrap block
	for (cc in 1:length(NewBlocl)){
		BlockCol = NewBlocl[[cc]]
		NewBlockCol=lapply(1:length(BlockCol), function(rr){
			Block.cur=BlockCol[[rr]]
			Nrow=nrow(Block.cur)
			Ncol=ncol(Block.cur)
			Adj.cur=ConvertAdj(Block.cur)
			if (Nrow==1 || Ncol==1){OutB = Block.cur}
			else {
				Mimic = BayatiBetween5(Adj.cur, seq(Nrow), Nrow+seq(Ncol))
				if (length(Mimic)==1){OutB = Block.cur}
				else{
					NedgeE=Mimic[[3]]
					NewAdj=ConvertEtoA(as.matrix(NedgeE), Nrow+Ncol)
					OutB=NewAdj[seq(Nrow), Nrow+seq(Ncol)]
				} ##end of if/else no edge can be generated
			} ##end of if/else	for singlton on row or column
			OutB
		}) ##end of NewBlockCol
		
		NewBlocl[[cc]]=NewBlockCol
	}  ##end of for loop
	#SaveNewBlocl=NewBlocl
	
	##now combind the blocks back to matrix
	ComRow=lapply(1:length(NewBlocl), function(k){
		CB1=NewBlocl[[k]][[1]]
		for (b in 2:length(NewBlocl[[k]])){
			Add.B=NewBlocl[[k]][[b]]
			CB1=rbind(CB1,Add.B)
		}
		CB1
	})
		
	ComCol = ComRow[[1]]
	for (cb in 2:length(ComRow)){
		Add.C=ComRow[[cb]]
		ComCol=cbind(ComCol, Add.C)
	}
	return(ComCol)
}

####GenbyBayati() is and update function from GenbyBayati()
####           add a tuning parameter that if previous algorithm cannot generate
####           a new same degree block after Ntime iteration time,
####           then we randomly permute rows and columns(avoid endless loop)
####input: TreeA=Row tree, TreeB=Column tree, 
####		N1=# of cluster in row tree
####		N2=# of cluster in column tree
####        Ntime=a number gives the threshold of iteration time
####output: new matrix with fix block structure


GenbyBayati2 = function(TreeA, TreeB, N1, N2, Matrix, Ntime){
	
	##chop the original matrix by each block
	OldBlocl=CutMatrix(TreeA, TreeB, N1, N2, Matrix)
	NewBlocl=OldBlocl
	
	##for each block, generate a new bootstrap block
	for (cc in 1:length(NewBlocl)){
		BlockCol = NewBlocl[[cc]]
		NewBlockCol=lapply(1:length(BlockCol), function(rr){
			Block.cur=BlockCol[[rr]]
			Nrow=nrow(Block.cur)
			Ncol=ncol(Block.cur)
			Adj.cur=ConvertAdj(Block.cur)
			if (Nrow==1 || Ncol==1){OutB = Block.cur}
			else {
				Mimic = BayatiBetween6(Adj.cur,seq(Nrow),Nrow+seq(Ncol),Ntime)
				if (length(Mimic)==1){OutB = Block.cur}
				else{
					NedgeE=Mimic[[3]]
					if (length(NedgeE)!=1){
						NewAdj=ConvertEtoA(as.matrix(NedgeE), Nrow+Ncol)
						OutB=NewAdj[seq(Nrow), Nrow+seq(Ncol)]
					}
					else {OutB = RamPerm(Block.cur)}	
					##if bayati runs too long, then random permute the block
				} ##end of if/else no edge can be generated
			} ##end of if/else	for singlton on row or column
			OutB
		}) ##end of NewBlockCol
		
		NewBlocl[[cc]]=NewBlockCol
	}  ##end of for loop
	#SaveNewBlocl=NewBlocl
	
	##now combind the blocks back to matrix
	ComRow=lapply(1:length(NewBlocl), function(k){
		CB1=NewBlocl[[k]][[1]]
		for (b in 2:length(NewBlocl[[k]])){
			Add.B=NewBlocl[[k]][[b]]
			CB1=rbind(CB1,Add.B)
		}
		CB1
	})
		
	ComCol = ComRow[[1]]
	for (cb in 2:length(ComRow)){
		Add.C=ComRow[[cb]]
		ComCol=cbind(ComCol, Add.C)
	}
	return(ComCol)
}



####GenbyRamP() function generate a new data matrix
####              by block structure with random permutation
####input: TreeA=Row tree, TreeB=Column tree, 
####		N1=# of cluster in row tree
####		N2=# of cluster in column tree
####output: new matrix with fix block structure


GenbyRamP = function(TreeA, TreeB, N1, N2, Matrix){
	
	##chop the original matrix by each block
	OldBlocl=CutMatrix(TreeA, TreeB, N1, N2, Matrix)
	NewBlocl=OldBlocl
	
	##for each block, generate a new bootstrap block
	for (cc in 1:length(NewBlocl)){
		BlockCol = NewBlocl[[cc]]
		NewBlockCol=lapply(1:length(BlockCol), function(rr){
			Block.cur=BlockCol[[rr]]
			Nrow=nrow(Block.cur)
			Ncol=ncol(Block.cur)
			Adj.cur=ConvertAdj(Block.cur)
			if (Nrow==1 || Ncol==1){OutB = Block.cur}
			else {OutB = RamPerm(Block.cur)} 
			##end of if/else	for singlton on row or column
			OutB
		}) ##end of NewBlockCol
		
		NewBlocl[[cc]]=NewBlockCol
	}  ##end of for loop
	
	##now combind the blocks back to matrix
	ComRow=lapply(1:length(NewBlocl), function(k){
		CB1=NewBlocl[[k]][[1]]
		for (b in 2:length(NewBlocl[[k]])){
			Add.B=NewBlocl[[k]][[b]]
			CB1=rbind(CB1,Add.B)
		}
		CB1
	})
		
	ComCol = ComRow[[1]]
	for (cb in 2:length(ComRow)){
		Add.C=ComRow[[cb]]
		ComCol=cbind(ComCol, Add.C)
	}
	return(ComCol)
}


